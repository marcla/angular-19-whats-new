#+TITLE:    Angular what's new (16.x ‚Üí 19.x)
#+AUTHOR:   Claudio Marchiori
#+LANGUAGE: it

* Componenti Standalone

- [[https://angular.dev/guide/components#using-components][Guida ufficiale Angular]]
# - [[][Playground]]

In Angular 16 √® stata introdotta una nuova tipologia di componenti, le *standalone components*, che offrono un modo pi√π semplice e modulare di sviluppare le applicazioni.
La principale differenza rispetto ai componenti tradizionali √® che non necessitano di essere dichiarati all'interno di un modulo *NgModule*. Questo semplifica la struttura e il boilerplate del codice, rendendolo pi√π leggibile e manutenibile.
Un componente standalone dichiara le proprie dipendenze (componenti, direttive e pipe) direttamente tramite la propriet√† ~imports~ del decoratore ~@Component~.

*Vantaggi*

  - Eliminazione dei moduli NgModule: struttura pi√π semplice e meno codice.
  - Maggiore modularit√†: componenti, direttive e pipe pi√π indipendenti e riutilizzabili.
  - Migliore leggibilit√† e manutenibilit√† del codice.

** Approccio con moduli (Angular < 16)

#+BEGIN_SRC typescript
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatTooltipModule } from '@angular/material/tooltip';
import { ReactiveFormsModule } from '@angular/forms';
import { FooService } from './foo.service';
import { ButtonComponent } from './button.component';

@NgModule({
  declarations: [ButtonComponent, /* ... */],
  providers: [FooService, /* ... */],
  imports: [
    CommonModule,
    MatIconModule,
    MatButtonModule,
    MatTooltipModule,
    ReactiveFormsModule,
    /* ... */
  ],
  exports: [ButtonComponent, /* ... */]
})
export class ButtonModule { }
#+END_SRC

** Approccio con componenti standalone (Angular >= 16)

#+BEGIN_SRC typescript
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatTooltipModule } from '@angular/material/tooltip';
import { ReactiveFormsModule } from '@angular/forms';
import { FooService } from './foo.service';

@Component({
  selector: 'app-button',
  standalone: true, // ‚Üê definizione di un componente standalone
  imports: [ // ‚Üê Qui si dichiarano le dipendenze
    CommonModule,
    MatIconModule,
    MatButtonModule,
    MatTooltipModule,
    ReactiveFormsModule,
    /* ... */
  ]
  providers: [FooService, /* ... */], // ‚Üê Qui si dichiarano i servizi
  template: `
    <button mat-raised-button
            [matTooltip]="tooltip"
            (click)="onClick()">
      <mat-icon>{{ icon }}</mat-icon>
      {{ label }}
    </button>
  `,
  styles: [],
})
export class ButtonComponent {
  @Input() icon!: string;
  @Input() label!: string;
  @Input() tooltip!: string;

  myForm = new FormGroup({
    name: new FormControl('')
  });

  onClick() {
    // Esempio di logica con Reactive Forms
    console.log(this.myForm.value);
  }
}
#+END_SRC

** Componenti Standalone

Un componente standalone √® un componente a tutti gli effetti, con la differenza che viene definito come tale tramite la propriet√† ~standalone: true~ nel decoratore.

#+BEGIN_SRC typescript
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule } from '@angular/forms';

@Component({
  selector: 'app-my-component',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, /* ... */]
  template: `
    <p>This is a standalone component!</p>
  `,
  styles: [],
  providers: [],
})
export class MyComponent { }
#+END_SRC

*** Direttive Standalone

Anche le direttive possono essere definite come standalone, utilizzando la stessa propriet√† ~standalone: true~ nel decoratore ~@Directive~.

#+BEGIN_SRC typescript
@Directive({
  selector: '[appMyAttribute]',
  standalone: true,
  providers: []
})
export class MyAttributeDirective { }
#+END_SRC

*** Pipe Standalone

Analogamente, anche le pipe possono essere standalone e dichiarate all'interno della sezione ~imports~ del componente che le utilizza.

#+BEGIN_SRC typescript
@Pipe({
  name: 'myFilter',
  standalone: true
})
export class MyFilterPipe implements PipeTransform {
  transform(value: any, ...args: any[]): any {
    // Logica della pipe
    return value;
  }
}
#+END_SRC

*** Esempio di utilizzo

In un componente standalone, puoi importare direttamente altri componenti, direttive o pipe standalone:

#+BEGIN_SRC typescript
import { MyAppComponent } from './my-app.component';
import { MyAttributeDirective } from './my-attribute.directive';
import { MyFilterPipe } from './my-filter.pipe';
import { FooService } from './foo.service';

@Component({
  // ...
  standalone: true,
  imports: [MyAppComponent, MyAttributeDirective, MyFilterPipe],
  providers: [FooService],
  /* ... */
})
export class MyParentComponent { /* ... */ }
#+END_SRC

** Componenti, direttive e pipe standalone: una distinzione importante

Come abbiamo visto, i componenti standalone offrono un approccio pi√π snello e modulare allo sviluppo in Angular, eliminando la necessit√† di dichiararli all'interno di un modulo NgModule. Tuttavia, √® fondamentale fare una distinzione tra componenti, direttive e pipe standalone:

- *Componenti standalone*: *devono* dichiarare le proprie dipendenze (componenti, direttive e pipe) tramite la propriet√† ~imports~ del decoratore ~@Component~. Questo √® necessario perch√© il componente standalone deve sapere quali altri elementi pu√≤ utilizzare nel suo template e nella sua logica.

- *Direttive e pipe standalone*: *non* necessitano di importare la propriet√† ~imports~. Questo perch√© direttive e pipe, per loro natura, non hanno dipendenze da altri componenti, direttive o pipe. Sono elementi "autonomi" che vengono utilizzati *dai* componenti, ma non ne "importano" altri.

*** Perch√© questa differenza?

La differenza fondamentale risiede nel ruolo che componenti, direttive e pipe svolgono all'interno dell'applicazione:

- *Componenti*: sono i "mattoni" fondamentali dell'interfaccia utente. Possono contenere altri componenti, utilizzare direttive e pipe, e hanno una logica propria. Per questo motivo, hanno bisogno di "sapere" quali sono le loro dipendenze, e lo fanno tramite ~imports~.

- *Direttive*: sono "*istruzioni*" che modificano il comportamento o l'aspetto degli elementi del DOM. Non "contengono" altri elementi, ma vengono "utilizzate" da essi. Per questo motivo, non hanno bisogno di importare nulla.

- *Pipe*: trasformano i dati in un formato specifico. Anche loro sono "autonome" e non dipendono da altri elementi.

** Retrocompatibilit√†

Per iniziare a convertire dei componenti contenuti in un modulo in *standalone components* √® possibile utilizzare questo approccio conservativo per mantenere la retrocompatibilit√†:

#+BEGIN_SRC typescript
import { MyStandaloneAppComponent } from './my-app.component';
import { MyStandaloneAttributeDirective } from './my-attribute.directive';
import { MyFilterPipe } from './my-filter.pipe';

@NgModule({
  declarations: [MyFilterPipe], // ‚Üê la classe MyFilterPipe non √® ancora stata dichiarata standalone
  imports: [ // ‚Üê questi componenti sono stati resi standalone e vengono importati solo per essere successivamente esportati
    MyStandaloneAppComponent,
    MyStandaloneAttributeDirective,
  ],
  exports: [MyFilterPipe, MyStandaloneAppComponent, MyStandaloneAttributeDirective]
})
export class MyOldModule { /* ... */ }
#+END_SRC

** Componenti Standalone: addio NgModule?

Con l'avvento dei componenti standalone, i moduli NgModule diventano opzionali. Questo non significa che siano completamente inutili, ma il loro ruolo cambia.

I moduli possono ancora essere utili per:
  - Organizzare il codice in unit√† logiche pi√π grandi.
  - Raggruppare componenti, direttive e pipe che vengono spesso utilizzati insieme.
  - Fornire configurazioni a livello di modulo (ad esempio, provider di servizi).

Tuttavia, per molte applicazioni, i componenti standalone offrono una soluzione pi√π semplice e diretta, eliminando la necessit√† di creare moduli per ogni componente.

*** forRoot e forChild: un nuovo approccio

I metodi ~forRoot~ e ~forChild~ erano spesso utilizzati con i moduli per configurare servizi e condividere dati tra componenti in modo gerarchico.
Con i componenti standalone, questo approccio cambia.

*Configurazione di servizi essenziali (HttpClient e Routing):*

- *HttpClient:* Per configurare ~HttpClient~, utilizza la funzione ~provideHttpClient()~ all'interno dell'array ~providers~ del metodo ~bootstrapApplication()~ (nel tuo file ~main.ts~):
  #+BEGIN_SRC typescript
  import { bootstrapApplication } from '@angular/platform-browser';
  import { AppComponent } from './app/app.component';
  import { provideHttpClient } from '@angular/common/http';

  bootstrapApplication(AppComponent, {
    providers: [
      provideHttpClient(/* ... */)
    ]
  });
  #+END_SRC

- *Routing:* Per il routing, utilizza la funzione ~provideRouter()~ sempre all'interno dell'array ~providers~ di ~bootstrapApplication()~:
  #+BEGIN_SRC typescript
  import { bootstrapApplication } from '@angular/platform-browser';
  import { AppComponent } from './app/app.component';
  import { provideRouter } from '@angular/router';
  import { routes } from './app.routes'; // Importa le tue rotte

  bootstrapApplication(AppComponent, {
    providers: [
      provideRouter(routes, withComponentInputBinding(), /* ... */)
    ]
  });
  #+END_SRC

-----

* Directive Composition API e hostDirectives in Angular

- [[https://angular.dev/guide/directives/directive-composition-api][Guida ufficiale Angular]] - [[https://stackblitz.com/edit/stackblitz-starters-jrxkcahg][Playground]]

A partire da Angular 16, √® possibile comporre componenti e direttive in modo pi√π modulare grazie alle *Directive Composition API*.

L'uso principale di ~hostDirectives~ √® *sulle direttive* per creare *comportamenti componibili e modulari*.
Questa tecnica permette di *raggruppare pi√π direttive in una sola*, mantenendo il codice pi√π pulito e riutilizzabile.

L'elemento chiave di questa API √® la propriet√† ~hostDirectives~, che consente di *aggregare direttive standalone* in un componente o in una direttiva (standalone) senza modificarne il template.

*üîπ Vantaggi principali:*
  - *Riutilizzo del codice* ‚Üí le direttive possono essere condivise tra pi√π componenti senza dichiararle nel template.
  - *Separazione delle responsabilit√†* ‚Üí ogni direttiva pu√≤ gestire una specifica funzionalit√† senza mescolarsi con la logica del componente.
  - *Mappatura di Input/Output* ‚Üí consente di rinominare ~@Input~ e ~@Output~ delle direttive per adattarli al contesto del componente.
  - *Leggibilit√† migliorata:* ‚Üí il codice √® pi√π conciso e focalizzato sulla logica specifica della direttiva "ospitante".

*üîπ Quando usare hostDirectives?*
- *Principalmente nelle direttive*, per creare comportamenti riutilizzabili senza ereditariet√† complessa.
- *Nei componenti solo se strettamente necessario*, quando si vuole includere automaticamente una direttiva senza dichiararla nel template.

#+BEGIN_SRC typescript
/* ‚Üì @Directive */
@Directive({
  selector: '[appAdvancedTooltip]',
  standalone: true,
  hostDirectives: [{ directive: TooltipDirective, inputs: ['message'], outputs: ['onShow'] }]
})
export class AdvancedTooltipDirective {}

/* ‚Üì @Component */
@Component({
  selector: 'app-loading-button',
  standalone: true,
  template: `<button>Carica</button>`,
  hostDirectives: [{ directive: PositionDirective, inputs: ['someInput'], outputs: ['someOutput'] }]
})
export class LoadingButtonComponent {}
#+END_SRC

** Differenza tra hostDirectives ed ereditariet√† classica

L'uso di ~hostDirectives~ *non* fa ereditare i metodi interni della direttiva aggiunta, *a differenza di `extends`* nell'ereditariet√† classica.

*Differenza tra `hostDirectives` ed `extends`*
| Caratteristica               | `extends` (Ereditariet√† classica) | `hostDirectives` |
|------------------------------|----------------------------------|------------------|
| *Eredita metodi e propriet√† protette/private* | ‚úÖ S√¨ | ‚ùå No |
| *Eredita input/output* | ‚ùå No (deve essere ridefinito) | ‚úÖ S√¨ (se esplicitamente mappato) |
| *Eredita metodi pubblici* | ‚úÖ S√¨ | ‚ùå No |
| *Supporta pi√π "estensioni"* | ‚ùå No (solo una classe base) | ‚úÖ S√¨ (pu√≤ aggregare pi√π direttive) |

** Cosa eredita hostDirectives?

- ‚úî *Solo ci√≤ che √® esplicitamente mappato negli `inputs` e `outputs`*
- ‚úî Il comportamento della direttiva (influisce sullo stesso host element)
- ‚úñ *Non eredita metodi o propriet√† pubbliche della direttiva inclusa*

üí° *Se hai bisogno di accedere a metodi della direttiva inclusa, devi ottenere manualmente un riferimento a essa.*

** Esempio: cosa NON viene ereditato
#+BEGIN_SRC typescript
@Directive({
  selector: '[appBase]',
  standalone: true
})
export class BaseDirective {
  @Input() value = 'Base Value';

  logMessage() {
    console.log(`Metodo interno della direttiva che stampa ${this.value}`);
  }
}

@Directive({
  selector: '[appEnhanced]',
  standalone: true,
  hostDirectives: [
    {
      directive: BaseDirective,
      inputs: ['value'] // ‚Üê Necessario specificare le inputs se se ne vuole fare uso
    }
  ]
})
export class EnhancedDirective {
  constructor() {} // ‚Üê Non √® necessario super() nel costruttore

  ngOnInit() {
    this.logMessage(); // ‚ùå Errore: logMessage() non √® disponibile!
  }
}
#+END_SRC

üî¥ *Errore:* il metodo ~logMessage()~ non viene ereditato da ~BaseDirective~.

** Come accedere ai metodi di una direttiva inclusa?
Devi *iniettare la direttiva inclusa* manualmente nel costruttore:
#+BEGIN_SRC typescript
@Directive({
  selector: '[appEnhanced]',
  standalone: true,
  hostDirectives: [{ directive: BaseDirective, inputs: ['value'] }]
})
export class EnhancedDirective {
  constructor(private baseDirective: BaseDirective) {}

  ngOnInit() {
    this.baseDirective.logMessage(); // ‚úÖ Funziona!
  }
}
#+END_SRC

üëâ Ora ~logMessage()~ √® accessibile perch√© otteniamo un riferimento esplicito a ~BaseDirective~.

*üìå √à obbligatorio specificare inputs e outputs?*
No, non √® obbligatorio.
Tuttavia, *se non vengono specificati, il componente o la direttiva che utilizza =hostDirectives= non erediter√† automaticamente gli input/output della direttiva.*

*üîπ Cosa succede se non vengono dichiarati?*
- Gli input e gli output della direttiva *non saranno accessibili* nel contesto in cui √® usata.
- Se il componente o la direttiva tenta di accedere a un input/output non mappato, *Angular non generer√† errori*, ma semplicemente ignorer√† tali propriet√†.

‚úÖ *Esempio senza mapping di inputs/outputs*
#+BEGIN_SRC typescript
@Directive({
  selector: '[appExample]',
  standalone: true,
  hostDirectives: [{ directive: SomeDirective }]
})
export class ExampleDirective {}
#+END_SRC
üëâ Qui, ~appExample~ utilizza ~SomeDirective~, *ma non ha accesso ai suoi input/output* perch√© non sono stati mappati.

** Usare hostDirectives nei componenti

*üìå Quando usare hostDirectives in un componente?*
- Quando si vuole *aggregare direttive* senza doverle dichiarare nel template.
- Quando si ha bisogno di *mappare gli input/output* di una direttiva in modo che siano gestiti direttamente dal componente.
- Per favorire un'architettura basata sulla *composizione anzich√© l'ereditariet√†*.

*‚ùå Quando *NON* usare hostDirectives in un componente?*
1. *Se la direttiva pu√≤ essere dichiarata nel template con [myDirective]*
   - Se l'unico motivo per usare =hostDirectives= √® evitare di scrivere la direttiva nel template, allora probabilmente *non √® necessario*.

2. *Se la direttiva modifica il DOM del componente*
   - =hostDirectives= *non modifica il template*, ma solo i suoi host bindings.
   - Se hai bisogno di cambiare il DOM, usa invece una direttiva strutturale (=*ngIf=, =*ngFor=).

-----

* Lazy-loading Components

- [[https://angular.dev/guide/components/programmatic-rendering#lazy-loading-components][Guida ufficiale Angular]]
# - [[][Playground]]

A partire da Angular 17, √® possibile *caricare dinamicamente i componenti in modo lazy* senza doverli dichiarare manualmente nei moduli o nei componenti host.

*Perch√© usare il Lazy-Loading dei componenti?*
- ‚úî *Migliorare le performance* riducendo il bundle iniziale dell‚Äôapp.
- ‚úî *Evitare dipendenze inutili* quando un componente non √® sempre necessario.
- ‚úî *Caricare componenti solo quando servono*, ad esempio modali, tabelle avanzate o widget dinamici.

Prima di Angular 17, per creare un componente dinamico si utilizzava =ViewContainerRef= e =ComponentFactoryResolver=, ma ora Angular fornisce un metodo pi√π semplice ed efficiente.

** üîπ Come caricare un componente in modo lazy
Il metodo chiave √® =import()=, che consente di caricare un componente solo quando richiesto.

*‚úÖ Esempio base: caricamento dinamico di un componente*
Supponiamo di avere un *componente pesante*, ad esempio una tabella avanzata, che vogliamo caricare solo quando serve.

Nel componente host, utilizziamo =ViewContainerRef= e il nuovo metodo =viewContainerRef.createComponent()=

#+BEGIN_SRC typescript
/* ‚Üì Il componente che verr√† caricato lazy */
@Component({
  selector: 'app-lazy-table',
  standalone: true,
  template: `<h2>Tabella Lazy</h2>`
})
export class LazyTableComponent {
  @Input() data!: string;
}

/* ‚Üì Il componente host */
@Component({
  selector: 'app-dashboard',
  standalone: true,
  template: `
    <button (click)="loadTable()">Carica Tabella</button>
    <ng-container #container></ng-container>
  `
})
export class DashboardComponent {
  @ViewChild('container', { read: ViewContainerRef }) container!: ViewContainerRef;

  async loadTable() {
    this.container.clear();

    const { LazyTableComponent } = await import('./lazy-table.component'); // ‚Üê Qui viene importato il componente
    const componentRef = this.container.createComponent(LazyTableComponent); // ‚Üê Qui viene creato il componente

    componentRef.setInput('data', 'Dati caricati dinamicamente!'); // ‚Üê Qui riceve i valori dell'input
  }
}
#+END_SRC

** Conclusione
- *Lazy-loading dei componenti* ‚Üí permette di caricare dinamicamente elementi solo quando servono.
- *Angular 17+ semplifica il processo* ‚Üí con =import()= e =createComponent()=.
- *√à possibile passare input dinamici* ‚Üí ai componenti caricati in modo lazy.

-----

* Nuove Lifecycle Hooks in Angular: afterRender, afterNextRender e DestroyRef

- [[https://angular.dev/guide/components/lifecycle#afterrender-and-afternextrender][Guida ufficiale Angular]]
# - [[][Playground]]

Con l‚Äôintroduzione delle nuove versioni di Angular, sono stati aggiunti nuovi lifecycle hooks che migliorano la gestione del rendering e della distruzione dei componenti. In particolare:

- *afterRender*: viene eseguito *dopo che il template √® stato renderizzato e la change detection √® completata*.
- *afterNextRender*: viene eseguito *solo una volta dopo il primo rendering del template*.
- *DestroyRef*: una nuova API che semplifica la gestione della pulizia delle risorse senza dover implementare ~OnDestroy~.

*Differenza tra afterRender e afterNextRender*

*Definizione chiara*:

- *afterRender* viene chiamato *dopo ogni rendering del template*, quindi pu√≤ essere eseguito pi√π volte durante il ciclo di vita del componente, ogni volta che Angular aggiorna il DOM in seguito a un cambiamento dello stato.
- *afterNextRender* viene chiamato *solo una volta, dopo il primo rendering del template*, e non si ripete pi√π per l‚Äôintero ciclo di vita del componente.

*Esempio pratico di afterRender e afterNextRender*:

#+BEGIN_SRC typescript
import { Component, effect, afterRender, afterNextRender, Signal, signal } from '@angular/core';

@Component({
  selector: 'app-demo',
  template: `<p>Contatore: {{ count() }}</p>
             <button (click)="increment()">Incrementa</button>`
})
export class DemoComponent {
  count: Signal<number> = signal(0);

  constructor() {
    afterRender(() => {
      console.log('afterRender: Il template √® stato aggiornato!');
    });

    afterNextRender(() => {
      console.log('afterNextRender: Questo viene eseguito solo dopo il primo rendering.');
    });
  }

  increment() {
    this.count.set(this.count() + 1);
  }
}
#+END_SRC

** Confronto con i Lifecycle Hooks tradizionali

*Differenze con i precedenti lifecycle hooks*:

| Hook                        | Quando viene eseguito                                                   | Esegue il codice pi√π volte? |
|-----------------------------|------------------------------------------------------------------------|-----------------------------|
| *ngOnInit*                  | Dopo la creazione del componente, prima del primo rendering           | No                          |
| *ngOnChanges*               | Ad ogni modifica degli input bindings                                 | S√¨                          |
| *ngAfterContentInit*        | Dopo che il contenuto proiettato (ng-content) √® stato inizializzato   | No                          |
| *ngAfterContentChecked*     | Dopo ogni change detection sul contenuto proiettato                   | S√¨                          |
| *ngAfterViewInit*           | Dopo che la view e i figli sono stati inizializzati                   | No                          |
| *ngAfterViewChecked*        | Dopo ogni change detection della view                                | S√¨                          |
| *afterRender*               | Dopo ogni aggiornamento del template e della change detection         | S√¨                          |
| *afterNextRender*           | Solo una volta, dopo il primo rendering del template                 | No                          |

*Esempi di differenze*:

- *ngAfterViewInit* √® utile quando bisogna eseguire codice dopo che la view √® stata inizializzata, ma viene chiamato solo una volta.
- *afterRender* pu√≤ essere utile per operazioni che devono avvenire *dopo ogni aggiornamento del DOM*, ad esempio per sincronizzare dati o interagire con librerie esterne.
- *ngAfterViewChecked* si attiva ad ogni change detection, ma pu√≤ essere inefficiente se non gestito correttamente.
- *afterNextRender* √® utile per inizializzazioni che devono avvenire *dopo il primo rendering* e non ripetersi.

** Distruzione dei componenti: DestroyRef e OnDestroy

Prima di Angular 16, la gestione della pulizia delle risorse avveniva con l‚Äôimplementazione dell‚Äôinterfaccia ~OnDestroy~:

#+BEGIN_SRC typescript
import { Component, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-demo',
  template: `<p>Componente con OnDestroy</p>`
})
export class DemoComponent implements OnDestroy {
  ngOnDestroy() {
    console.log('Il componente sta per essere distrutto!');
  }
}
#+END_SRC

*Problema*:
Il metodo ~ngOnDestroy()~ richiede di implementare un‚Äôinterfaccia e pu√≤ portare a codice boilerplate nei componenti.

*Soluzione: DestroyRef*
Con Angular 16+ possiamo usare ~DestroyRef~ per registrare delle callback da eseguire quando il componente viene distrutto:

#+BEGIN_SRC typescript
import { Component, inject, DestroyRef } from '@angular/core';

@Component({
  selector: 'app-demo',
  template: `<p>Componente con DestroyRef</p>`
})
export class DemoComponent {
  private destroyRef = inject(DestroyRef);

  constructor() {
    this.destroyRef.onDestroy(() => {
      console.log('Il componente sta per essere distrutto con DestroyRef!');
    });
  }
}
#+END_SRC

*Vantaggi di DestroyRef*:
- *Non richiede di implementare OnDestroy*.
- *Pu√≤ essere usato direttamente nei servizi*, mentre ~ngOnDestroy~ √® disponibile solo nei componenti o direttive.
- *Consente una gestione pi√π pulita della distruzione*.

*Esempio pratico con Observable*
Immaginiamo di avere un componente che si iscrive a un ~Observable~:

#+BEGIN_SRC typescript
import { Component, inject, DestroyRef } from '@angular/core';
import { interval, Subscription } from 'rxjs';

@Component({
  selector: 'app-timer',
  template: `<p>Timer attivo...</p>`
})
export class TimerComponent {
  private destroyRef = inject(DestroyRef);
  private subscription: Subscription;

  constructor() {
    this.subscription = interval(1000).subscribe(val => console.log('Tick:', val));

    this.destroyRef.onDestroy(() => {
      console.log('Cleanup: annulliamo la subscription.');
      this.subscription.unsubscribe();
    });
  }
}
#+END_SRC

*Confronto tra ngOnDestroy e DestroyRef*

| Caratteristica                  | OnDestroy       | DestroyRef        |
|----------------------------------|----------------|-------------------|
| Richiede implementazione        | *S√¨*           | *No*             |
| Pu√≤ essere usato nei servizi    | *No*           | *S√¨*             |
| Si integra con Dependency Injection | *No*       | *S√¨*             |
| Registra pi√π callback           | *No*           | *S√¨*             |

---

** Conclusione

- *afterRender*: eseguito *dopo ogni aggiornamento del template*.
- *afterNextRender*: eseguito *una sola volta dopo il primo rendering*.
- *ngOnDestroy*: metodo classico per la pulizia dei componenti.
- *DestroyRef*: API moderna per registrare callback di cleanup in modo pi√π flessibile.

*Quando usare cosa?*
- Usa *afterRender* se vuoi eseguire azioni *dopo ogni aggiornamento del DOM*.
- Usa *afterNextRender* se vuoi un‚Äôinizializzazione *solo dopo il primo rendering*.
- Usa *ngOnDestroy* se vuoi seguire il metodo tradizionale.
- Usa *DestroyRef* per un approccio pi√π pulito e moderno.

-----

* Content Projection con <ng-content>

- [[https://angular.dev/guide/components/content-projection][Guida ufficiale Angular]]
# - [[][Playground]]

** Introduzione

La content projection √® una funzionalit√† di Angular che consente di inserire contenuti esterni all'interno di un componente. A partire dalla versione 16, Angular ha introdotto nuove funzionalit√† per rendere la content projection pi√π potente e flessibile, come il supporto per i *valori di default* nei blocchi ~<ng-content>~.

** Default Value per la Content Projection (Novit√† dalla v16)

A partire da Angular 16, √® possibile definire un *valore di default* per i blocchi ~<ng-content>~. Se il contenuto proiettato non √® fornito, verr√† utilizzato il valore di default.

#+BEGIN_SRC html
<!-- Componente figlio -->
<div class="card">
  <ng-content select="[header]">
    <p>Intestazione predefinita</p> <!-- Valore di default -->
  </ng-content>
  <ng-content select="[body]">
    <p>Corpo predefinito</p> <!-- Valore di default -->
  </ng-content>
</div>

<!-- Componente genitore -->
<app-card>
  <!-- Nessun contenuto proiettato per [header] e [body] -->
</app-card>
#+END_SRC

*Risultato*
#+BEGIN_SRC html
<app-card>
  <div class="card">
    <p>Intestazione predefinita</p>
    <p>Corpo predefinito</p>
  </div>
</app-card>
#+END_SRC

-----

* Deferred Loading con @defer (Novit√† dalla v17)

- [[https://angular.dev/guide/templates/defer][Guida ufficiale Angular]]
# - [[][Playground]]

** Introduzione

Il deferred loading (caricamento differito) √® una tecnica che consente di caricare parti di un'applicazione solo quando sono necessarie, migliorando le prestazioni iniziali. Angular introduce la direttiva ~@defer~ a partire dalla versione 17 per implementare facilmente questa funzionalit√†. Questa direttiva √® particolarmente utile per ottimizzare il caricamento di componenti pesanti, moduli o risorse che non sono necessari immediatamente.

** Utilizzo di @defer

La direttiva ~@defer~ permette di ritardare il caricamento di un blocco di template fino al verificarsi di una condizione specifica, come l'interazione dell'utente o il raggiungimento di un determinato stato.

*** Esempio base

#+BEGIN_SRC html
@defer {
  @defer (on viewport) {
  <app-heavy-component></app-heavy-component>
} @placeholder {
  <div>Caricamento in corso...</div>
}
}
#+END_SRC

*** Trigger disponibili
Angular supporta diversi trigger per il caricamento differito:
- ~on viewport~: Carica il contenuto quando entra nel viewport (ad esempio, quando l'utente scorre fino a quel punto).
- ~on interaction~: Carica il contenuto quando l'utente interagisce con un elemento (ad esempio, un clic o un tocco).
- ~on hover~: Carica il contenuto quando l'utente passa il mouse su un elemento.
- ~on idle~: Carica il contenuto quando il browser √® inattivo (dopo il caricamento iniziale della pagina).
- ~on timer~: Carica il contenuto dopo un determinato ritardo (ad esempio, 2 secondi).
- ~on immediate~: Carica il contenuto immediatamente dopo il rendering iniziale (utile per testare il comportamento).

*** Esempi avanzati

1. *Caricamento su interazione:*
   #+BEGIN_SRC html
   @defer (on interaction) {
     <app-heavy-component></app-heavy-component>
   } @placeholder {
     <button>Clicca per caricare</button>
   }
   #+END_SRC

2. *Caricamento con ritardo:*
   #+BEGIN_SRC html
   @defer (on timer(2000)) {
     <app-heavy-component></app-heavy-component>
   } @placeholder {
     <div>Caricamento tra 2 secondi...</div>
   }
   #+END_SRC

3. *Combinazione di trigger:*
   #+BEGIN_SRC html
   @defer (on viewport; on interaction) {
     <app-heavy-component></app-heavy-component>
   } @placeholder {
     <div>Scorri o clicca per caricare</div>
   }
   #+END_SRC

*** Gestione degli stati

Angular fornisce blocchi aggiuntivi per gestire gli stati del caricamento differito:
- ~@placeholder~: Definisce un contenuto temporaneo da mostrare durante l'attesa del caricamento.
- ~@loading~: Definisce un contenuto da mostrare durante il caricamento effettivo (ad esempio, uno spinner).
- ~@error~: Definisce un contenuto da mostrare in caso di errore durante il caricamento.

*Esempio completo:*

#+BEGIN_SRC html
@defer (on viewport) {
  <app-heavy-component></app-heavy-component>
} @placeholder {
  <div>Contenuto in caricamento...</div>
} @loading {
  <div>Caricamento in corso...</div>
} @error {
  <div>Errore durante il caricamento.</div>
}
#+END_SRC

*** Prefetching delle risorse

Angular supporta anche il prefetching delle risorse, che consente di caricare in anticipo i componenti o i moduli necessari, senza renderli immediatamente visibili. Questo √® utile per migliorare l'esperienza utente quando si prevede che una risorsa sar√† presto necessaria.

*Esempio:*

#+BEGIN_SRC html
@defer (on interaction; prefetch on viewport) {
  <app-heavy-component></app-heavy-component>
} @placeholder {
  <button>Clicca per caricare</button>
}
#+END_SRC

** Casi d'uso pratici

1. *Componenti pesanti:*
   - Utilizzare ~@defer~ per caricare componenti complessi o pesanti solo quando sono visibili o necessari.
   - Esempio: Caricare un grafico o una mappa solo quando l'utente scorre fino a quella sezione.

2. *Moduli lazy-loaded:*
   - Combinare ~@defer~ con il lazy loading dei moduli per ottimizzare ulteriormente le prestazioni.
   - Esempio: Caricare un modulo di amministrazione solo quando l'utente accede a quella sezione.

3. *Risorse esterne:*
   - Utilizzare ~@defer~ per caricare risorse esterne, come video o immagini di grandi dimensioni, solo quando necessario.
   - Esempio: Caricare un video solo quando l'utente interagisce con un pulsante di riproduzione.

** Vantaggi del Deferred Loading

- *Prestazioni migliorate:* Riduce il carico iniziale dell'applicazione, migliorando i tempi di caricamento.
- *Esperienza utente ottimizzata:* Carica solo ci√≤ che √® necessario, quando √® necessario, evitando rallentamenti.
- *Flessibilit√†:* Supporta diversi trigger e stati per adattarsi a vari scenari.
- *Integrazione con il lazy loading:* Funziona perfettamente con il lazy loading dei moduli per un'ottimizzazione completa.

-----

* Variabili nei Template con @let (Angular 18)

- [[https://angular.dev/guide/templates/variables#using-let][Guida ufficiale Angular]]
# - [[][Playground]]

** Introduzione

A partire dalla versione 18, Angular introduce la sintassi ~@let~ per definire variabili direttamente nei template. Questo semplifica la gestione di valori calcolati o complessi all'interno dei template, migliorando la leggibilit√† e la manutenibilit√† del codice.

** Utilizzo di @let
La sintassi ~@let~ permette di definire una variabile all'interno di un blocco di template, che pu√≤ essere riutilizzata in seguito.

*** Esempio di base

#+BEGIN_SRC html
@let total = item.price * item.quantity;

<p>Totale: {{ total }}</p>
#+END_SRC

*** Utilizzo con condizioni
#+BEGIN_SRC html
@let discount = user.isPremium ? 0.2 : 0;

<p>Sconto applicato: {{ discount * 100 }}%</p>
#+END_SRC

*** Utilizzo con funzioni
#+BEGIN_SRC html
@let formattedDate = formatDate(order.date);

<p>Data dell'ordine: {{ formattedDate }}</p>
#+END_SRC

*** Utilizzo con strutture di controllo
#+BEGIN_SRC html
@let utente = { nome: "Luca", loggato: true };

@if (utente.loggato) {
  <p>Benvenuto, {{ utente.nome }}!</p>
} @else {
  <p>Effettua il login</p>
}
#+END_SRC

** Vantaggi di @let

- *Leggibilit√†:* Riduce la complessit√† dei template evitando espressioni ripetute.
- *Manutenibilit√†:* Centralizza la logica di calcolo direttamente nel template.
- *Flessibilit√†:* Supporta valori calcolati, condizioni e chiamate a funzioni.

-----

* Signal in Angular

- [[http://localhost:4200/signal][Playground]]

** Introduzione ai Signal

Dalla versione *Angular 16*, √® stato introdotto il concetto di *Signal*, una nuova API per la gestione dello stato reattivo. I Signal rappresentano un'alternativa pi√π efficiente e prevedibile rispetto al tradizionale ~RxJS~, semplificando il tracking delle dipendenze e l'aggiornamento della UI.

A differenza degli `Observable`, i Signal sono *sincroni*, *privi di effetti collaterali* e *tracciano automaticamente le dipendenze*, riducendo la necessit√† di gestione esplicita delle sottoscrizioni.

** Perch√© Signal?

- ‚úÖ *Risoluzione automatica delle dipendenze*: i Signal notificano automaticamente i cambiamenti, eliminando la necessit√† di ~async pipe~ o ~subscribe~.
- ‚úÖ *Performance ottimizzate*: Angular ottimizza il rendering basandosi sui cambiamenti dei Signal, riducendo i cicli di change detection non necessari.
- ‚úÖ *API pi√π semplice*: la gestione dello stato diventa pi√π intuitiva e meno verbosa rispetto agli Observable.

** Creazione e utilizzo di un Signal
Per creare un Signal, si utilizza la funzione ~signal()~ fornita da Angular. √à possibile inizializzare il Signal con un valore predefinito e aggiornarlo utilizzando metodi specifici.

*** Esempio di base
#+BEGIN_SRC typescript
import { Component, signal } from '@angular/core';

@Component({
  selector: 'app-counter',
  template: `
    <p>Count: {{ count() }}</p>

    <button (click)="increment()">Increment</button>
  `,
})
export class CounterComponent {
  count = signal(0); // ‚Üê Signal con valore iniziale 0

  increment() {
    this.count.update((value) => value + 1); // ‚Üê Incrementa il valore
  }
}
#+END_SRC

** Aggiornamento di un Signal

I Signal offrono due metodi principali per modificarne il valore:

| Metodo         | Descrizione                                             |
|---------------|---------------------------------------------------------|
| `set(value)`  | Imposta direttamente il valore                          |
| `update(fn)`  | Modifica il valore in base allo stato corrente          |

** Signal e Computed Values
I Signal possono essere combinati con *computed values* per creare valori derivati che si aggiornano automaticamente quando i Signal di cui dipendono cambiano.

*** Esempio di computed value
#+BEGIN_SRC typescript
import { signal, computed } from '@angular/core';

const price = signal(10);
const quantity = signal(2);

// ‚Üì Calcolo del totale basato su price e quantity
const total = computed(() => price() * quantity());

console.log(total()); // Output: 20

// ‚Üì Aggiornamento di price
price.set(15);
console.log(total()); // Output: 30 (aggiornato automaticamente)
#+END_SRC

** Signal e Effetti
Gli *effetti* (~effect()~) sono funzioni che vengono eseguite automaticamente quando uno o pi√π Signal cambiano. Sono utili per eseguire operazioni collaterali, come il logging o l'interazione con API esterne.

*** Esempio di effetto
#+BEGIN_SRC typescript
import { signal, effect } from '@angular/core';

const count = signal(0);

// Effetto che viene eseguito ogni volta che count cambia
effect(() => {
  console.log('Count changed:', count());
});

count.set(1); // Log: "Count changed: 1"
count.set(2); // Log: "Count changed: 2"
#+END_SRC

** Integrazione tra Signal e RxJS
Angular fornisce due utility per integrare i Signal con gli Observable:
- ~toSignal~: Converte un Observable in un Signal.
- ~toObservable~: Converte un Signal in un Observable.

*** Conversione da Observable a Signal (toSignal)
#+BEGIN_SRC typescript
import { toSignal } from '@angular/core/rxjs-interop';
import { interval } from 'rxjs';

const source$ = interval(1000); // Observable che emette un valore ogni secondo
const count = toSignal(source$, { initialValue: 0 }); // Conversione in Signal

console.log(count()); // Output: 0 (valore iniziale)
// Dopo 1 secondo: count() sar√† 1, dopo 2 secondi: 2, e cos√¨ via...
#+END_SRC

*** Conversione da Signal a Observable (toObservable)
#+BEGIN_SRC typescript
import { signal } from '@angular/core';
import { toObservable } from '@angular/core/rxjs-interop';
import { take } from 'rxjs/operators';

const count = signal(0); // Signal con valore iniziale 0
const count$ = toObservable(count); // Conversione in Observable

count$.pipe(take(3)).subscribe((value) => {
  console.log('Observable value:', value);
});

count.set(1); // Log: "Observable value: 1"
count.set(2); // Log: "Observable value: 2"
count.set(3); // Log: "Observable value: 3"
#+END_SRC


** Casi d'uso pratici
1. *Gestione dello stato globale:*
   - Utilizzare i Signal per gestire lo stato globale dell'applicazione, sostituendo o integrando librerie come NgRx o Akita.

2. *Ottimizzazione delle prestazioni:*
   - Ridurre i cicli di change detection utilizzando i Signal per gestire solo le parti dello stato che cambiano frequentemente.

3. *Sostituzione di Observable semplici:*
   - Sostituire Observable semplici (ad esempio, per gestire un contatore o un flag) con Signal per una gestione pi√π diretta e meno verbosa.

4. *Integrazione con librerie basate su Observable:*
   - Utilizzare ~toObservable~ per integrare i Signal con librerie o servizi esistenti che si basano su Observable.

** Conclusione
I Signal rappresentano un'evoluzione significativa nella gestione dello stato in Angular, offrendo un approccio reattivo, efficiente e semplice da utilizzare. Con la loro integrazione nativa nel framework, i Signal sono destinati a diventare uno strumento fondamentale per gli sviluppatori Angular, specialmente nelle applicazioni moderne che richiedono alte prestazioni e una gestione dello stato ottimizzata.

-----

* Custom Event (Input) - Transizione da @Input() a input()

- [[http://localhost:4200/input-signal][Playground]]

** Introduzione
In Angular, la comunicazione tra componenti √® tradizionalmente gestita attraverso gli *input* e gli *output*. Con l'introduzione dei **Signal** in Angular 16 e l'evoluzione delle API nelle versioni successive, Angular ha introdotto un nuovo approccio per gestire gli input basato sui Signal, che sostituisce o integra il classico decoratore ~@Input~. Questo capitolo esplora le differenze tra il vecchio approccio (~@Input~) e il nuovo approccio basato sui Signal (~input()~), evidenziando i vantaggi, le nuove propriet√† come `required` e `transform`, e i casi d'uso.

** Il vecchio approccio: @Input()
Prima di Angular 17, gli input venivano dichiarati utilizzando il decoratore ~@Input~. Questo approccio √® ancora valido, ma √® meno integrato con il sistema reattivo di Angular basato sui Signal.

*** Esempio di @Input()
#+begin_src typescript
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<p>{{ message }}</p>`,
})
export class ChildComponent {
  @Input() message: string = ''; // Input tradizionale
}
#+end_src

*** Limitazioni di @Input()

- *Mancanza di reattivit√†:* Gli input tradizionali non sono reattivi di default. Se il valore cambia, il componente non viene automaticamente aggiornato a meno che non si utilizzi il change detection.
- *Verbosit√†:* Richiede l'uso di decoratori e non √® integrato con i Signal.

** Il nuovo approccio: input() basato su Signal

A partire da Angular 17, √® possibile utilizzare la funzione ~input()~ per dichiarare input reattivi basati sui Signal. Questo approccio √® pi√π moderno, reattivo e integrato con il sistema di change detection di Angular. Inoltre, introduce nuove propriet√† come `required` e `transform`.

*** Esempio di input()
#+begin_src typescript
import { Component, input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<p>{{ message() }}</p>`,
})
export class ChildComponent {
  message = input<string>(''); // Input basato su Signal
}
#+end_src

*** Vantaggi di input()
- *Reattivit√† integrata:* Gli input basati su Signal sono reattivi di default. Ogni cambiamento nel valore dell'input viene propagato automaticamente al componente.
- *Sintassi pi√π semplice:* Non √® necessario utilizzare decoratori, rendendo il codice pi√π conciso.
- *Integrazione con i Signal:* Gli input basati su Signal possono essere facilmente combinati con altri Signal o computed values.
- *Propriet√† avanzate:* Supporta propriet√† come `required` e `transform`.

** Propriet√† avanzate degli input Signal

*** required
La propriet√† `required` permette di dichiarare che un input √® obbligatorio. Se il valore non viene fornito, Angular generer√† un errore in fase di compilazione.

*** Esempio di input() con required
#+begin_src typescript
import { Component, input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<p>{{ message() }}</p>`,
})
export class ChildComponent {
  message = input.required<string>(); // Input obbligatorio
}
#+end_src

*** transform
La propriet√† `transform` permette di applicare una trasformazione al valore dell'input prima che venga utilizzato nel componente. Questo √® utile per convertire o validare i dati in ingresso.

*** Esempio di input() con transform
#+begin_src typescript
import { Component, input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<p>{{ message() }}</p>`,
})
export class ChildComponent {
  message = input('', {
    transform: (value: string | null) => value?.toUpperCase() ?? 'DEFAULT', // Trasforma il valore in maiuscolo
  });
}
#+end_src

** Confronto tra @Input() e input()
| Caratteristica               | @Input()                  | input()                   |
|------------------------------|--------------------------|--------------------------|
| *Reattivit√†*                 | No                       | S√¨                       |
| *Sintassi*                   | Decoratore (~@Input~)    | Funzione (~input()~)     |
| *Integrazione con Signal*    | No                       | S√¨                       |
| *Change Detection*           | Richiede change detection| Automatico               |
| *Propriet√† avanzate*         | No                       | S√¨ (required, transform) |

** Conclusione

La transizione da ~@Input()~ a ~input()~ rappresenta un'evoluzione significativa nella gestione degli input in Angular. Gli input basati su Signal offrono maggiore reattivit√†, una sintassi pi√π semplice, una migliore integrazione con il sistema di change detection e nuove propriet√† avanzate come `required` e `transform`. Tuttavia, gli output rimangono basati su ~@Output~ e ~EventEmitter~, in attesa di future evoluzioni del framework.

-----

* Two-Way Binding con Model Inputs (Novit√† dalla v17)

** Introduzione
Angular 17 introduce una nuova funzionalit√† chiamata *Model Inputs*, che semplifica il two-way binding senza dover utilizzare la sintassi ~[(ngModel)]~. Questa funzionalit√† √® particolarmente utile per sincronizzare lo stato tra un componente padre e un componente figlio in modo pi√π intuitivo.

** Utilizzo di Model Inputs
Per utilizzare i Model Inputs, √® sufficiente definire una propriet√† con il decoratore ~@Model~ nel componente figlio. Questo permette di sincronizzare automaticamente il valore tra il componente padre e il componente figlio.

*** Esempio di Model Input
#+begin_src typescript
import { Component, model } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `
    <input [ngModel]="value()" (ngModelChange)="value.set($event)" />
  `,
})
export class ChildComponent {
  value = model<string>(); // Model Input per il two-way binding
}
#+end_src

*** Utilizzo nel componente padre
#+begin_src typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    <app-child [(value)]="parentValue"></app-child>
    <p>Valore nel padre: {{ parentValue }}</p>
  `,
})
export class ParentComponent {
  parentValue = 'Hello from parent!';
}
#+end_src

** Vantaggi
- *Sintassi semplificata:* Elimina la necessit√† di utilizzare ~[(ngModel)]~ per il two-way binding.
- *Maggiore chiarezza:* Il codice √® pi√π leggibile e intuitivo.
- *Integrazione con i Signal:* I Model Inputs funzionano perfettamente con i Signal.

** Conclusione
I Model Inputs rappresentano un'evoluzione del two-way binding in Angular, rendendo la sincronizzazione tra componenti pi√π semplice e moderna.

-----

* View Queries (ViewChild / ViewChildren)

** Introduzione
Le *view queries* permettono di accedere a elementi del DOM o a componenti/direttive all'interno del template di un componente. Angular fornisce due decoratori per questo scopo: ~@ViewChild~ e ~@ViewChildren~.

** ViewChild
Il decoratore ~@ViewChild~ permette di ottenere un riferimento a un singolo elemento, componente o direttiva nel template.

*** Esempio di ViewChild
#+begin_src typescript
import { Component, ViewChild, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    <app-child #child></app-child>
  `,
})
export class ParentComponent implements AfterViewInit {
  @ViewChild('child') childComponent!: ChildComponent;

  ngAfterViewInit() {
    console.log(this.childComponent); // Accesso al componente figlio
  }
}
#+end_src

** ViewChildren
Il decoratore ~@ViewChildren~ permette di ottenere un riferimento a pi√π elementi, componenti o direttive nel template.

*** Esempio di ViewChildren
#+begin_src typescript
import { Component, ViewChildren, QueryList, AfterViewInit } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    <app-child></app-child>
    <app-child></app-child>
  `,
})
export class ParentComponent implements AfterViewInit {
  @ViewChildren(ChildComponent) childComponents!: QueryList<ChildComponent>;

  ngAfterViewInit() {
    this.childComponents.forEach((child) => {
      console.log(child); // Accesso a tutti i componenti figli
    });
  }
}
#+end_src

** Conclusione
Le view queries sono uno strumento potente per interagire con elementi del DOM o componenti direttamente dal codice TypeScript. ~@ViewChild~ √® utile per riferimenti singoli, mentre ~@ViewChildren~ √® ideale per gestire pi√π elementi.

-----

* Content Queries (ContentChild / ContentChildren)

** Introduzione
Le *content queries* permettono di accedere a elementi o componenti proiettati all'interno di un componente utilizzando ~<ng-content>~. Angular fornisce due decoratori per questo scopo: ~@ContentChild~ e ~@ContentChildren~.

** ContentChild
Il decoratore ~@ContentChild~ permette di ottenere un riferimento a un singolo elemento o componente proiettato.

*** Esempio di ContentChild
#+begin_src typescript
import { Component, ContentChild, AfterContentInit } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    <ng-content></ng-content>
  `,
})
export class ParentComponent implements AfterContentInit {
  @ContentChild('projectedContent') projectedElement!: any;

  ngAfterContentInit() {
    console.log(this.projectedElement); // Accesso all'elemento proiettato
  }
}
#+end_src

** ContentChildren
Il decoratore ~@ContentChildren~ permette di ottenere un riferimento a pi√π elementi o componenti proiettati.

*** Esempio di ContentChildren
#+begin_src typescript
import { Component, ContentChildren, QueryList, AfterContentInit } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    <ng-content></ng-content>
  `,
})
export class ParentComponent implements AfterContentInit {
  @ContentChildren(ChildComponent) projectedComponents!: QueryList<ChildComponent>;

  ngAfterContentInit() {
    this.projectedComponents.forEach((child) => {
      console.log(child); // Accesso a tutti i componenti proiettati
    });
  }
}
#+end_src

** Conclusione
Le content queries sono utili per interagire con contenuti proiettati all'interno di un componente. ~@ContentChild~ √® adatto per riferimenti singoli, mentre ~@ContentChildren~ √® ideale per gestire pi√π elementi.

-----

* LinkedSignal (Novit√† dalla v18)

** Introduzione
I *LinkedSignal* sono una nuova funzionalit√† introdotta in Angular 18 che permette di creare Signal collegati tra loro. Quando un Signal cambia, tutti i Signal collegati vengono aggiornati automaticamente. Questo √® utile per gestire relazioni complesse tra stati in modo reattivo.

** Utilizzo di LinkedSignal
Per creare un LinkedSignal, si utilizza la funzione ~linkedSignal~, che collega due o pi√π Signal.

*** Esempio di LinkedSignal
#+begin_src typescript
import { signal, linkedSignal } from '@angular/core';

const sourceSignal = signal(0);
const linkedSignal = linkedSignal(sourceSignal, (value) => value * 2);

console.log(linkedSignal()); // Output: 0

sourceSignal.set(5);
console.log(linkedSignal()); // Output: 10 (aggiornato automaticamente)
#+end_src

** Conclusione
I LinkedSignal semplificano la gestione di relazioni complesse tra stati, migliorando la reattivit√† e la manutenibilit√† del codice.

-----

* Signal Form (Novit√† dalla v18)

** Introduzione
I *Signal Form* sono una nuova funzionalit√† introdotta in Angular 18 che permette di gestire i form in modo reattivo utilizzando i Signal. Questo approccio √® pi√π semplice e performante rispetto ai form reattivi tradizionali.

** Utilizzo di Signal Form
Per creare un Signal Form, si utilizza la funzione ~signalForm~, che restituisce un oggetto reattivo per gestire lo stato del form.

*** Esempio di Signal Form
#+begin_src typescript
import { signalForm } from '@angular/forms';

const form = signalForm({
  name: '',
  email: '',
});

form.valueChanges.subscribe((value) => {
  console.log('Form value changed:', value);
});

form.setValue({ name: 'John', email: 'john@example.com' });
#+end_src

** Conclusione
I Signal Form offrono un approccio moderno e reattivo per gestire i form in Angular, migliorando le prestazioni e la semplicit√† del codice.

-----

* HttpResource (Novit√† dalla v18)

** Introduzione
Gli *HttpResource* sono una nuova funzionalit√† introdotta in Angular 18 che semplifica la gestione delle richieste HTTP utilizzando i Signal. Questo approccio √® pi√π reattivo e integrato con il sistema di change detection di Angular.

** Utilizzo di HttpResource
Per creare un HttpResource, si utilizza la funzione ~httpResource~, che restituisce un oggetto reattivo per gestire le richieste HTTP.

*** Esempio di HttpResource
#+begin_src typescript
import { httpResource } from '@angular/common/http';

const resource = httpResource('https://api.example.com/data');

resource.get().subscribe((data) => {
  console.log('Data received:', data);
});
#+end_src

** Conclusione
Gli HttpResource semplificano la gestione delle richieste HTTP in Angular, migliorando la reattivit√† e l'integrazione con il framework.
