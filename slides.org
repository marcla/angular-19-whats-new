#+TITLE:    Angular what's new (16.x -> 19.x)
#+AUTHOR:   Claudio Marchiori
#+LANGUAGE: it

* Componenti Standalone

In Angular 16 √® stata introdotta una nuova tipologia di componenti, le *standalone components*, che offrono un modo pi√π semplice e modulare di sviluppare le applicazioni.
La principale differenza rispetto ai componenti tradizionali √® che non necessitano di essere dichiarati all'interno di un modulo *NgModule*. Questo semplifica la struttura e il boilerplate del codice, rendendolo pi√π leggibile e manutenibile.
Un componente standalone dichiara le proprie dipendenze (componenti, direttive e pipe) direttamente tramite la propriet√† ~imports~ del decoratore ~@Component~.

**Vantaggi**

  - Eliminazione dei moduli NgModule: struttura pi√π semplice e meno codice.
  - Maggiore modularit√†: componenti, direttive e pipe pi√π indipendenti e riutilizzabili.
  - Migliore leggibilit√† e manutenibilit√† del codice.

** Approccio con moduli (Angular < 16)

#+begin_src typescript
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatTooltipModule } from '@angular/material/tooltip';
import { ReactiveFormsModule } from '@angular/forms';
import { FooService } from './foo.service';
import { ButtonComponent } from './button.component';

@NgModule({
  declarations: [ButtonComponent, /* ... */],
  providers: [FooService, /* ... */],
  imports: [
    CommonModule,
    MatIconModule,
    MatButtonModule,
    MatTooltipModule,
    ReactiveFormsModule,
    /* ... */
  ],
  exports: [ButtonComponent, /* ... */]
})
export class ButtonModule { }
#+end_src

** Approccio con componenti standalone (Angular >= 16)

#+begin_src typescript
import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatTooltipModule } from '@angular/material/tooltip';
import { ReactiveFormsModule } from '@angular/forms';
import { FooService } from './foo.service';

@Component({
  selector: 'app-button',
  standalone: true, // ‚Üê definizione di un componente standalone
  imports: [ // ‚Üê Qui si dichiarano le dipendenze
    CommonModule,
    MatIconModule,
    MatButtonModule,
    MatTooltipModule,
    ReactiveFormsModule,
    /* ... */
  ]
  providers: [FooService, /* ... */], // ‚Üê Qui si dichiarano i servizi
  template: `
    <button mat-raised-button
            [matTooltip]="tooltip"
            (click)="onClick()">
      <mat-icon>{{ icon }}</mat-icon>
      {{ label }}
    </button>
  `,
  styles: [],
})
export class ButtonComponent {
  @Input() icon!: string;
  @Input() label!: string;
  @Input() tooltip!: string;

  myForm = new FormGroup({
    name: new FormControl('')
  });

  onClick() {
    // Esempio di logica con Reactive Forms
    console.log(this.myForm.value);
  }
}
#+end_src

** Componenti Standalone

Un componente standalone √® un componente a tutti gli effetti, con la differenza che viene definito come tale tramite la propriet√† ~standalone: true~ nel decoratore.

#+begin_src typescript
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule } from '@angular/forms';

@Component({
  selector: 'app-my-component',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, /* ... */]
  template: `
    <p>This is a standalone component!</p>
  `,
  styles: [],
  providers: [],
})
export class MyComponent { }
#+end_src

*** Direttive Standalone

Anche le direttive possono essere definite come standalone, utilizzando la stessa propriet√† ~standalone: true~ nel decoratore ~@Directive~.

#+begin_src typescript
@Directive({
  selector: '[appMyAttribute]',
  standalone: true,
  providers: []
})
export class MyAttributeDirective { }
#+end_src

*** Pipe Standalone

Analogamente, anche le pipe possono essere standalone e dichiarate all'interno della sezione ~imports~ del componente che le utilizza.

#+begin_src typescript
@Pipe({
  name: 'myFilter',
  standalone: true
})
export class MyFilterPipe implements PipeTransform {
  transform(value: any, ...args: any[]): any {
    // Logica della pipe
    return value;
  }
}
#+end_src

*** Esempio di utilizzo

In un componente standalone, puoi importare direttamente altri componenti, direttive o pipe standalone:

#+begin_src typescript
import { MyAppComponent } from './my-app.component';
import { MyAttributeDirective } from './my-attribute.directive';
import { MyFilterPipe } from './my-filter.pipe';
import { FooService } from './foo.service';

@Component({
  // ...
  standalone: true,
  imports: [MyAppComponent, MyAttributeDirective, MyFilterPipe],
  providers: [FooService],
  /* ... */
})
export class MyParentComponent { /* ... */ }
#+end_src

** Componenti, direttive e pipe standalone: una distinzione importante

Come abbiamo visto, i componenti standalone offrono un approccio pi√π snello e modulare allo sviluppo in Angular, eliminando la necessit√† di dichiararli all'interno di un modulo NgModule. Tuttavia, √® fondamentale fare una distinzione tra componenti, direttive e pipe standalone:

- **Componenti standalone**: *devono* dichiarare le proprie dipendenze (componenti, direttive e pipe) tramite la propriet√† ~imports~ del decoratore ~@Component~. Questo √® necessario perch√© il componente standalone deve sapere quali altri elementi pu√≤ utilizzare nel suo template e nella sua logica.

- **Direttive e pipe standalone**: *non* necessitano di importare la propriet√† ~imports~. Questo perch√© direttive e pipe, per loro natura, non hanno dipendenze da altri componenti, direttive o pipe. Sono elementi "autonomi" che vengono utilizzati *dai* componenti, ma non ne "importano" altri.

*** Perch√© questa differenza?

La differenza fondamentale risiede nel ruolo che componenti, direttive e pipe svolgono all'interno dell'applicazione:

- **Componenti**: sono i "mattoni" fondamentali dell'interfaccia utente. Possono contenere altri componenti, utilizzare direttive e pipe, e hanno una logica propria. Per questo motivo, hanno bisogno di "sapere" quali sono le loro dipendenze, e lo fanno tramite ~imports~.

- **Direttive**: sono "*istruzioni*" che modificano il comportamento o l'aspetto degli elementi del DOM. Non "contengono" altri elementi, ma vengono "utilizzate" da essi. Per questo motivo, non hanno bisogno di importare nulla.

- **Pipe**: trasformano i dati in un formato specifico. Anche loro sono "autonome" e non dipendono da altri elementi.

** Retrocompatibilit√†

Per iniziare a convertire dei componenti contenuti in un modulo in *standalone components* √® possibile utilizzare questo approccio conservativo per mantenere la retrocompatibilit√†:

#+begin_src typescript
import { MyStandaloneAppComponent } from './my-app.component';
import { MyStandaloneAttributeDirective } from './my-attribute.directive';
import { MyFilterPipe } from './my-filter.pipe';

@NgModule({
  declarations: [MyFilterPipe], // ‚Üê la classe MyFilterPipe non √® ancora stata dichiarata standalone
  imports: [ // ‚Üê questi componenti sono stati resi standalone e vengono importati solo per essere successivamente esportati
    MyStandaloneAppComponent,
    MyStandaloneAttributeDirective,
  ],
  exports: [MyFilterPipe, MyStandaloneAppComponent, MyStandaloneAttributeDirective]
})
export class MyOldModule { /* ... */ }
#+end_src

* Directive Composition API e hostDirectives in Angular

- [[https://angular.dev/guide/directives/directive-composition-api][Guida ufficiale Angular]] ([[https://stackblitz.com/edit/stackblitz-starters-jrxkcahg][Playground]])

A partire da Angular 16, √® possibile comporre componenti e direttive in modo pi√π modulare grazie alle **Directive Composition API**.
L'elemento chiave di questa API √® la propriet√† =hostDirectives=, che consente di **aggregare direttive standalone** in un componente senza modificarne il template.

**üîπ Vantaggi principali:**
- **Riutilizzo del codice** ‚Üí le direttive possono essere condivise tra pi√π componenti senza dichiararle nel template.
- **Separazione delle responsabilit√†** ‚Üí ogni direttiva pu√≤ gestire una specifica funzionalit√† senza mescolarsi con la logica del componente.
- **Mappatura di Input/Output** ‚Üí consente di rinominare =@Input= e =@Output= delle direttive per adattarli al contesto del componente.

**üîπ Quando usare hostDirectives?**
- **Principalmente nelle direttive**, per creare comportamenti riutilizzabili senza ereditariet√† complessa.
- **Nei componenti solo se strettamente necessario**, quando si vuole includere automaticamente una direttiva senza dichiararla nel template.

#+BEGIN_SRC typescript
@Component({
  selector: 'app-loading-button',
  standalone: true,
  template: `<button>Carica</button>`,
  hostDirectives: [{ directive: MyDirective, inputs: ['someInput'], outputs: ['someOutput'] }]
})
export class LoadingButtonComponent {}
#+END_SRC

** Differenza tra hostDirectives ed ereditariet√† classica

L'uso di =hostDirectives= **non** fa ereditare i metodi interni della direttiva aggiunta, **a differenza di `extends`** nell'ereditariet√† classica.

**üìå Differenza tra `hostDirectives` ed `extends`**
| Caratteristica               | `extends` (Ereditariet√† classica) | `hostDirectives` |
|------------------------------|----------------------------------|------------------|
| **Eredita metodi e propriet√† protette/private** | ‚úÖ S√¨ | ‚ùå No |
| **Eredita input/output** | ‚ùå No (deve essere ridefinito) | ‚úÖ S√¨ (se esplicitamente mappato) |
| **Eredita metodi pubblici** | ‚úÖ S√¨ | ‚ùå No |
| **Supporta pi√π "estensioni"** | ‚ùå No (solo una classe base) | ‚úÖ S√¨ (pu√≤ aggregare pi√π direttive) |

---

*** Cosa eredita hostDirectives?

- ‚úî **Solo ci√≤ che √® esplicitamente mappato negli `inputs` e `outputs`**
- ‚úî Il comportamento della direttiva (influisce sullo stesso host element)
- ‚úñ **Non eredita metodi o propriet√† pubbliche della direttiva inclusa**

üí° **Se hai bisogno di accedere a metodi della direttiva inclusa, devi ottenere manualmente un riferimento a essa.**

---

*** üìå Esempio: cosa NON viene ereditato
#+BEGIN_SRC typescript
@Directive({
  selector: '[appBase]',
  standalone: true
})
export class BaseDirective {
  @Input() value = 'Base Value';

  logMessage() {
    console.log('Metodo interno della direttiva');
  }
}

@Directive({
  selector: '[appEnhanced]',
  standalone: true,
  hostDirectives: [{ directive: BaseDirective, inputs: ['value'] }]
})
export class EnhancedDirective {
  constructor() {}

  ngOnInit() {
    this.logMessage(); // ‚ùå Errore: logMessage() non √® disponibile!
  }
}
#+END_SRC

üî¥ **Errore:** il metodo =logMessage()= non viene ereditato da =BaseDirective=.

---

*** üìå Come accedere ai metodi di una direttiva inclusa?
Devi **iniettare la direttiva inclusa** manualmente nel costruttore:
#+BEGIN_SRC typescript
@Directive({
  selector: '[appEnhanced]',
  standalone: true,
  hostDirectives: [{ directive: BaseDirective, inputs: ['value'] }]
})
export class EnhancedDirective {
  constructor(private baseDirective: BaseDirective) {}

  ngOnInit() {
    this.baseDirective.logMessage(); // ‚úÖ Funziona!
  }
}
#+END_SRC

üëâ Ora =logMessage()= √® accessibile perch√© otteniamo un riferimento esplicito a =BaseDirective=.

---

**üìå √à obbligatorio specificare inputs e outputs?**
No, non √® obbligatorio.
Tuttavia, **se non vengono specificati, il componente o la direttiva che utilizza =hostDirectives= non erediter√† automaticamente gli input/output della direttiva.**

**üîπ Cosa succede se non vengono dichiarati?**
- Gli input e gli output della direttiva **non saranno accessibili** nel contesto in cui √® usata.
- Se il componente o la direttiva tenta di accedere a un input/output non mappato, **Angular non generer√† errori**, ma semplicemente ignorer√† tali propriet√†.

‚úÖ **Esempio senza mapping di inputs/outputs**
#+BEGIN_SRC typescript
@Directive({
  selector: '[appExample]',
  standalone: true,
  hostDirectives: [{ directive: SomeDirective }]
})
export class ExampleDirective {}
#+END_SRC
üëâ Qui, =appExample= utilizza =SomeDirective=, **ma non ha accesso ai suoi input/output** perch√© non sono stati mappati.

---

*** üìå hostDirectives

L'uso principale di =hostDirectives= √® **sulle direttive** per creare **comportamenti componibili e modulari**.
Questa tecnica permette di **raggruppare pi√π direttive in una sola**, mantenendo il codice pi√π pulito e riutilizzabile.

‚úÖ **Esempio: composizione di direttive**
#+BEGIN_SRC typescript
@Directive({
  selector: '[appAdvancedTooltip]',
  standalone: true,
  hostDirectives: [{ directive: TooltipDirective, inputs: ['message'], outputs: ['onShow'] }]
})
export class AdvancedTooltipDirective {}
#+END_SRC
üëâ Qui, la direttiva =appAdvancedTooltip= **integra automaticamente** il comportamento di =TooltipDirective=, evitando di doverla dichiarare esplicitamente nel template.


#+BEGIN_COMMENT

**üìå Quando usare hostDirectives in un componente?**
- Quando si vuole **aggregare direttive** senza doverle dichiarare nel template.
- Quando si ha bisogno di **mappare gli input/output** di una direttiva in modo che siano gestiti direttamente dal componente.
- Per favorire un'architettura basata sulla **composizione anzich√© l'ereditariet√†**.

**‚úÖ Esempio corretto di utilizzo:**
#+BEGIN_SRC typescript
@Component({
  selector: 'app-loading-button',
  standalone: true,
  template: `<button>Carica</button>`,
  hostDirectives: [{ directive: MyDirective, inputs: ['someInput'], outputs: ['someOutput'] }]
})
export class LoadingButtonComponent {}
#+END_SRC

---

**‚ùå Quando *NON* usare hostDirectives in un componente?**
1. **Se la direttiva pu√≤ essere dichiarata nel template con [myDirective]**
   - Se l'unico motivo per usare =hostDirectives= √® evitare di scrivere la direttiva nel template, allora probabilmente **non √® necessario**.

2. **Se la direttiva modifica il DOM del componente**
   - =hostDirectives= **non modifica il template**, ma solo i suoi host bindings.
   - Se hai bisogno di cambiare il DOM, usa invece una direttiva strutturale (=*ngIf=, =*ngFor=).

---


**üìå √à obbligatorio specificare inputs e outputs in hostDirectives?**
No, non √® obbligatorio.
Se non vengono specificati, il componente **non eredita automaticamente gli input e gli output della direttiva**.

**üîπ Cosa succede se non vengono dichiarati?**
- Gli input e gli output della direttiva **non saranno accessibili nel componente**.
- Se il componente tenta di accedere a un input/output che non √® stato mappato, Angular non generer√† errori, ma semplicemente non lo considerer√†.

**‚úÖ Esempio senza mapping di inputs/outputs**
#+BEGIN_SRC typescript
@Component({
  selector: 'app-example',
  standalone: true,
  template: `<p>Componente senza input mappati</p>`,
  hostDirectives: [{ directive: SomeDirective }]
})
export class ExampleComponent {}
#+END_SRC
üëâ In questo caso, **il componente user√† la direttiva**, ma non avr√† accesso ai suoi input/output.

---

**üìå Conclusione**
- =hostDirectives= √® uno strumento potente per **comporre comportamenti senza modificare il template del componente**.
- Se gli input/output non sono mappati, il componente non potr√† utilizzarli.
- Se la direttiva √® gi√† dichiarata nel template, =hostDirectives= potrebbe non essere necessario.
- Non pu√≤ **modificare il DOM del componente**, ma solo i suoi binding.

üí° **Utilizzalo quando serve maggiore modularit√† e componibilit√† nel codice Angular!** üöÄ
#+END_COMMENT

#+BEGIN_COMMENT
 **~hostDirectives~: un ponte tra direttive**

  - Immagina di avere una direttiva ~appCustomStyle~ che applica stili personalizzati a un elemento, e una direttiva ~appTooltip~ che aggiunge un tooltip.
  - Con ~hostDirectives~, puoi creare una nuova direttiva ~appStyledTooltip~ che "combina" le funzionalit√† di ~appCustomStyle~ e ~appTooltip~ semplicemente "ospitandole" al suo interno.
  - In questo modo, ~appStyledTooltip~ erediter√† automaticamente gli stili personalizzati di ~appCustomStyle~ e il tooltip di ~appTooltip~, senza doverne riscrivere il codice.

  #+begin_src typescript
  @Directive({
    selector: '[appCustomStyle]',
    standalone: true,
    inputs: ['customStyleInput'], // Input di esempio
    outputs: ['customStyleOutput'] // Output di esempio
  })
  export class CustomStyleDirective {
    @Input() customStyleInput: any;
    @Output() customStyleOutput = new EventEmitter<any>();
    // Logica per applicare stili personalizzati
  }

  @Directive({
    selector: '[appTooltip]',
    standalone: true,
    inputs: ['tooltipText'], // Input di esempio
    outputs: ['tooltipShown'] // Output di esempio
  })
  export class TooltipDirective {
    @Input() tooltipText: string;
    @Output() tooltipShown = new EventEmitter<boolean>();
    // Logica per aggiungere un tooltip
  }

  @Directive({
    selector: '[appStyledTooltip]',
    standalone: true,
    hostDirectives: [
      {
        directive: CustomStyleDirective,
        inputs: ['customStyleInput'], // Mappa l'input di CustomStyleDirective
        outputs: ['customStyleOutput'] // Mappa l'output di CustomStyleDirective
      },
      {
        directive: TooltipDirective,
        // tooltipText non viene mappato, quindi usa il valore di default
        outputs: ['tooltipShown'] // Mappa l'output di TooltipDirective
      }
    ]
  })
  export class StyledTooltipDirective {
    // Logica specifica per la direttiva combinata
  }
  #+end_src

**Input e output opzionali**

  - Come mostrato nell'esempio, √® possibile omettere la mappatura di alcuni input o output nella definizione di ~hostDirectives~.
  - Se un input non viene mappato, la direttiva "ospitata" utilizzer√† il suo valore di default.
  - Se un output non viene mappato, l'evento corrispondente non sar√† accessibile dalla direttiva "ospitante".
  - Questa flessibilit√† permette di personalizzare il comportamento delle direttive "ospitate" in base alle esigenze specifiche della direttiva "ospitante".

**Vantaggi di ~hostDirectives~:**

  - **Riuso di codice potenziato:** Riutilizza intere direttive senza doverne copiare e incollare il codice.
  - **Modularit√† estrema:** Crea direttive "combinate" a partire da direttive pi√π piccole e specializzate.
  - **Manutenibilit√† semplificata:** Modifiche a una direttiva "ospitata" si riflettono automaticamente in tutte le direttive che la utilizzano.
  - **Leggibilit√† migliorata:** Il codice √® pi√π conciso e focalizzato sulla logica specifica della direttiva "ospitante".

**Considerazioni importanti:**

  - Le direttive utilizzate in ~hostDirectives~ devono essere standalone.
  - √à possibile mappare gli input e gli output delle direttive "ospitate" per personalizzarne il comportamento all'interno della direttiva "ospitante".

#+END_COMMENT

#+BEGIN_COMMENT
** Lazy-loading components
** viewProvider
** DOM APIs
*** afterRender & afterNextRender
*** DestroyRef

* Signal
* Extra
#+END_COMMENT
